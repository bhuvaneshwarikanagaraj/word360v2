<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>word 360</title>

  <!-- LogRocket initialization -->
  <script src="https://cdn.lr-ingest.com/LogRocket.min.js"></script>
  <script>
    window.LogRocket && window.LogRocket.init('biy3cl/spelling');
    
    // Track page view
    LogRocket.track('Login Page View');
  </script>

    <style>
    @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
      font-family: 'Nunito', 'Comic Sans MS', cursive, sans-serif;
    }
    
    :root {
      --primary: #6366F1;
      --primary-light: #818CF8;
      --primary-dark: #4F46E5;
      --secondary: #FB7185;
      --success: #22C55E;
      --success-light: #86EFAC;
      --success-dark: #16A34A;
      --warning: #FBBF24;
      --danger: #F87171;
      --background: #F3F4F6;
      --white: #FFFFFF;
      --text-dark: #374151;
      --text-light: #6B7280;
      --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      --radius: 16px;
        }

        body {
      background-color: var(--background);
      color: var(--text-dark);
      min-height: 100vh;
      position: relative;
      padding-bottom: 30px;
      margin: 0;
      overflow-x: hidden;
      scroll-behavior: smooth;
    }

    .container {
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
      padding: 15px;
      min-height: 100vh;
      display: none;
      flex-direction: column;
    }

    .container.visible {
      display: flex;
    }

    #episodes-page {
      position: relative;
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
      height: 100vh;
      display: none;
      flex-direction: column;
    }

    #episodes-page.visible {
      display: flex;
    }

    .logo {
      text-align: center;
      padding-top: 20px;
      flex-shrink: 0;
    }
    
    .logo h1 {
      color: var(--primary);
      font-size: 32px;
      font-weight: 800;
      margin-bottom: 5px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .logo p {
      color: var(--secondary);
      font-size: 18px;
      font-weight: 600;
    }
    
    .auth-container {
      background-color: var(--white);
      border-radius: var(--radius);
      box-shadow: var(--shadow-lg);
      padding: 25px 20px;
      margin-top: 20px;
      position: relative;
            overflow: hidden;
    }
    
    .auth-container::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
            width: 100%;
      height: 8px;
      background: linear-gradient(90deg, var(--primary), var(--secondary), var(--success), var(--warning));
    }
    
    .auth-tabs {
            display: flex;
      margin-bottom: 25px;
      background-color: #F9FAFB;
      border-radius: 12px;
      overflow: hidden;
    }
    
    .auth-tab {
      flex: 1;
      padding: 14px 10px;
      text-align: center;
      cursor: pointer;
      font-weight: 700;
      font-size: 16px;
      transition: all 0.3s ease;
      color: var(--text-light);
    }
    
    .auth-tab.active {
      background-color: var(--primary);
      color: var(--white);
      box-shadow: var(--shadow);
    }
    
    .auth-form {
      display: none;
    }
    
    .auth-form.active {
      display: block;
      animation: fadeIn 0.5s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .form-group {
            margin-bottom: 20px;
      text-align: left;
    }
    
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: var(--text-dark);
      font-size: 15px;
    }
    
    input {
            width: 100%;
      padding: 12px 16px;
      border: 2px solid #E5E7EB;
      border-radius: 12px;
      font-size: 16px;
      transition: all 0.3s ease;
      background-color: #F9FAFB;
    }
    
    input:focus {
      border-color: var(--primary-light);
      outline: none;
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
    }
    
    button {
      background-color: var(--primary);
      color: white;
      border: none;
      border-radius: 12px;
      padding: 14px 20px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 700;
            width: 100%;
      box-shadow: 0 4px 6px rgba(99, 102, 241, 0.2);
    }
    
    button:hover {
      background-color: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: 0 6px 10px rgba(99, 102, 241, 0.3);
    }

    button:active {
      transform: translateY(0);
    }
    
    .episodes-container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 20px;
      overflow-y: auto;
      padding: 0 15px;
      flex: 1;
      padding-bottom: 100px;
      /* Hide scrollbar for Chrome, Safari and Opera */
      &::-webkit-scrollbar {
        display: none;
      }
      /* Hide scrollbar for IE, Edge and Firefox */
      -ms-overflow-style: none;  /* IE and Edge */
      scrollbar-width: none;  /* Firefox */
    }
    
    .episode-card {
      background-color: var(--white);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 15px;
      text-align: center;
      position: relative;
            transition: all 0.3s ease;
      overflow: hidden;
      display: flex;
      align-items: center;
      min-height: 80px;
      margin-bottom: 10px;
    }
    
    .episode-card:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow-lg);
    }
    
    .episode-card.locked {
      opacity: 0.7;
      cursor: not-allowed;
      position: relative;
      background: linear-gradient(135deg, rgba(156, 163, 175, 0.1), rgba(107, 114, 128, 0.1));
      border: 2px solid #9CA3AF;
    }
    
    .episode-card.locked .episode-number {
      background: linear-gradient(135deg, #9CA3AF, #6B7280);
      box-shadow: none;
    }

    .episode-card.locked .episode-title {
      color: #6B7280;
    }

    .episode-card.locked .episode-status {
      background-color: rgba(156, 163, 175, 0.2);
      color: #6B7280;
    }

    .episode-card.locked::after {
      content: "🔒";
      position: absolute;
      top: 50%;
      right: 15px;
      transform: translateY(-50%);
      font-size: 20px;
      color: #6B7280;
    }

    .episode-card.locked:hover {
      transform: none;
      box-shadow: var(--shadow);
    }
    
    .episode-number {
      background-color: var(--primary);
      color: white;
      width: 35px;
      height: 35px;
      min-width: 35px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
      font-weight: 700;
      font-size: 16px;
      margin-right: 12px;
      flex-shrink: 0;
    }
    
    .episode-content {
      flex-grow: 1;
      text-align: left;
      min-width: 0;
      padding-right: 10px;
    }
    
    .episode-title {
      font-weight: 700;
      margin-bottom: 4px;
      color: var(--text-dark);
      font-size: 15px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .episode-description {
      color: var(--text-light);
      font-size: 13px;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .lock-icon {
      position: absolute;
      top: 50%;
      right: 15px;
      transform: translateY(-50%);
      font-size: 20px;
      color: #9CA3AF;
    }
    
    .logout-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: var(--white);
      color: var(--danger);
      border: none;
      border-radius: 50%;
      width: 45px;
      height: 45px;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
      z-index: 10;
    }
    
    .logout-btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
      background-color: var(--danger);
      color: var(--white);
    }

    .hidden {
      display: none;
    }

    .episode-badge {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: rgba(52, 211, 153, 0.1);
      border-radius: var(--radius);
      font-weight: 700;
      color: var(--success);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .episode-card:hover .episode-badge {
      opacity: 1;
    }

    .episode-card:first-child .episode-badge {
      color: var(--success);
    }

    /* Episode Status Indicator */
    .episode-status {
      position: absolute;
      top: 8px;
      right: 8px;
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 12px;
      font-weight: 600;
      white-space: nowrap;
      background-color: rgba(99, 102, 241, 0.1);
      color: var(--primary);
    }

    .episode-status.available {
      background-color: rgba(34, 197, 94, 0.1);
      color: var(--success-dark);
    }

    .episode-status.locked {
      background-color: rgba(156, 163, 175, 0.2);
      color: #6B7280;
    }

    /* Progress bar for episodes */
    .progress-container {
      width: 100%;
      height: 10px;
      background-color: #E5E7EB;
      border-radius: 5px;
      margin: 20px 0;
      overflow: hidden;
      flex-shrink: 0;
    }

    .progress-bar {
      height: 100%;
      width: 20%; /* 1 out of 5 episodes */
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      border-radius: 5px;
    }

    /* Responsive adjustments */
    @media (min-width: 640px) {
      .episodes-container {
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
      }
      
      .container {
        padding: 20px;
      }
    }

    @media (max-width: 480px) {
      .episode-card {
        padding: 12px;
        min-height: 70px;
      }

      .episode-number {
        width: 30px;
        height: 30px;
        min-width: 30px;
        font-size: 14px;
        margin-right: 10px;
      }

      .episode-title {
        font-size: 14px;
      }

      .episode-status {
        font-size: 10px;
        padding: 2px 6px;
      }
    }

    @media (max-width: 360px) {
      .episode-card {
        padding: 10px;
        min-height: 60px;
      }

      .episode-number {
        width: 25px;
        height: 25px;
        min-width: 25px;
        font-size: 12px;
        margin-right: 8px;
      }

      .episode-title {
        font-size: 13px;
      }

      .episode-status {
        font-size: 9px;
        padding: 2px 5px;
      }
    }

    /* Animations */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .pulse {
      animation: pulse 2s infinite;
    }

    /* Blinking animation for text */
    @keyframes blink-text {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    .blink-text {
      animation: blink-text 1.5s infinite;
    }

    /* Badge for new episodes */
    .new-badge {
      position: absolute;
      top: -10px;
      right: -10px;
      background-color: var(--secondary);
      color: white;
      font-size: 12px;
      font-weight: 700;
      padding: 5px 10px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      transform: rotate(15deg);
    }

    /* Ripple effect for buttons */
    .ripple {
      position: relative;
      overflow: hidden;
    }

    .ripple:after {
      content: "";
      display: block;
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      pointer-events: none;
      background-image: radial-gradient(circle, #fff 10%, transparent 10.01%);
      background-repeat: no-repeat;
      background-position: 50%;
      transform: scale(10, 10);
      opacity: 0;
      transition: transform .5s, opacity 1s;
    }

    .ripple:active:after {
      transform: scale(0, 0);
      opacity: .3;
      transition: 0s;
    }

    /* Share popup styles */
    .share-popup {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .share-popup.active {
      display: flex;
      animation: fadeIn 0.3s ease;
    }

    .share-card {
      background: var(--white);
      padding: 30px;
      border-radius: var(--radius);
      text-align: center;
      position: relative;
      max-width: 90%;
      width: 350px;
      box-shadow: var(--shadow-lg);
    }

    .medal-icon {
      font-size: 60px;
      margin-bottom: 15px;
      animation: bounce 1s infinite;
    }

    .share-title {
      font-size: 24px;
      font-weight: 800;
      color: var(--primary);
      margin-bottom: 10px;
    }

    .share-text {
      color: var(--text-light);
      margin-bottom: 20px;
    }

    .share-button {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      background-color: #25D366;
      color: white;
      border: none;
      border-radius: 12px;
      padding: 12px 20px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: 0 auto;
    }

    .share-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(37, 211, 102, 0.3);
    }

    .close-popup {
      position: absolute;
      top: 15px;
      right: 15px;
      font-size: 24px;
      cursor: pointer;
      color: var(--text-light);
      transition: color 0.3s ease;
    }

    .close-popup:hover {
      color: var(--text-dark);
    }

    .permanent-share {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: #25D366;
      color: white;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      cursor: pointer;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
      z-index: 10;
    }

    .permanent-share:hover {
      transform: translateY(-3px) scale(1.1);
      box-shadow: 0 4px 12px rgba(37, 211, 102, 0.3);
    }

    .action-buttons {
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      gap: 20px;
      z-index: 10;
      padding: 0 20px;
      background: linear-gradient(to top, var(--background) 50%, transparent);
      padding-top: 20px;
    }

    .action-button {
      min-width: 120px;
      height: 45px;
      border-radius: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 0 20px;
      font-size: 16px;
      cursor: pointer;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
      background-color: var(--white);
      border: none;
      white-space: nowrap;
    }

    .action-button span.icon {
      font-size: 18px;
    }

    .action-button span.label {
      font-weight: 600;
    }

    .action-button:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .action-button.share {
      color: #25D366;
      background-color: var(--white);
    }

    .action-button.share:hover {
      background-color: #25D366;
      color: var(--white);
    }

    .action-button.logout {
      color: var(--danger);
      background-color: var(--white);
    }

    .action-button.logout:hover {
      background-color: var(--danger);
      color: var(--white);
    }

    @media (max-width: 768px) {
      .episodes-container {
        gap: 12px;
        padding-bottom: 80px;
      }

      .action-buttons {
        bottom: 15px;
        gap: 15px;
        padding: 0 15px;
      }

      .action-button {
        min-width: 100px;
        height: 40px;
        padding: 0 15px;
        font-size: 14px;
      }

      .action-button span.icon {
        font-size: 16px;
      }
    }

    /* Add padding to the bottom of the container to prevent overlap */
    .container {
      padding-bottom: 80px;
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    /* Add these new styles */
    .episode-card.completed {
        position: relative;
        background: linear-gradient(135deg, rgba(34, 197, 94, 0.05), rgba(22, 163, 74, 0.05));
        border: 2px solid var(--success);
        box-shadow: 0 0 5px rgba(34, 197, 94, 0.2);
    }

    .episode-card.completed .episode-number {
        background: linear-gradient(135deg, var(--success), var(--success-dark));
        box-shadow: 0 0 15px rgba(34, 197, 94, 0.2);
    }

    .episode-card.next {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(79, 70, 229, 0.1));
        border: 2px solid var(--primary);
        box-shadow: 0 0 10px rgba(99, 102, 241, 0.2);
        animation: next-episode-pulse 2s infinite;
    }

    @keyframes next-episode-pulse {
        0% { box-shadow: 0 0 10px rgba(99, 102, 241, 0.2); }
        50% { box-shadow: 0 0 15px rgba(99, 102, 241, 0.5); }
        100% { box-shadow: 0 0 10px rgba(99, 102, 241, 0.2); }
    }

    .episode-card.next .episode-number {
        background: linear-gradient(135deg, var(--primary), var(--primary-dark));
        box-shadow: 0 0 10px rgba(99, 102, 241, 0.3);
    }

    .episode-card.next .episode-status {
        background-color: rgba(99, 102, 241, 0.2);
        color: var(--primary);
        animation: blink-text 1.5s infinite;
    }

    .episode-card.completed .episode-title {
        color: var(--success);
        font-weight: 800;
    }

    .episode-card.next .episode-title {
        color: var(--primary);
        font-weight: 800;
    }

    .episode-card.completed .episode-status {
        background-color: rgba(34, 197, 94, 0.1);
        color: var(--success-dark);
    }

    .episode-card.next .episode-status {
        background-color: rgba(99, 102, 241, 0.2);
        color: var(--primary);
    }

    /* OTP styles */
    .otp-timer {
        text-align: center;
        margin: 10px 0;
        color: var(--text-light);
        font-size: 14px;
    }

    .resend-btn {
        margin-top: 10px;
        background-color: var(--text-light);
    }

    .resend-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    #otp-input {
        letter-spacing: 8px;
        font-size: 20px;
        text-align: center;
    }

    /* Add these styles */
    .phone-input-container {
        display: flex;
        gap: 10px;
        align-items: center;
    }

    .country-code {
        width: 120px;
        padding: 12px 16px;
        border: 2px solid #E5E7EB;
        border-radius: 12px;
        font-size: 16px;
        background-color: #F9FAFB;
        color: var(--text-dark);
    }

    .country-code:focus {
        border-color: var(--primary-light);
        outline: none;
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
    }

    #signup-phone, #login-phone {
        flex: 1;
    }

    /* Add these styles */
    .prompt-container {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        justify-content: center;
        align-items: center;
    }

    .prompt-content {
        background: var(--white);
        padding: 20px;
        border-radius: var(--radius);
        box-shadow: var(--shadow-lg);
        text-align: center;
        max-width: 90%;
        width: 300px;
    }

    .prompt-message {
        margin-bottom: 20px;
        color: var(--text-dark);
        font-size: 16px;
    }

    .prompt-button {
        background-color: var(--primary);
        color: white;
        border: none;
        border-radius: 8px;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .prompt-button:hover {
        background-color: var(--primary-dark);
    }

    .otp-timer {
        text-align: center;
        margin: 10px 0;
        color: var(--text-light);
        font-size: 14px;
        font-weight: 600;
    }

    .resend-btn {
        margin-top: 10px;
        background-color: var(--primary-light);
        opacity: 0.7;
        cursor: not-allowed;
    }

    .resend-btn:not(:disabled) {
        opacity: 1;
        cursor: pointer;
        background-color: var(--primary);
    }

    /* Add these styles */
    .back-btn {
        background-color: transparent;
        color: var(--text-light);
        border: 1px solid var(--text-light);
        margin-top: 10px;
    }

    .back-btn:hover {
        background-color: var(--text-light);
        color: white;
    }

    .step-indicator {
        display: flex;
        justify-content: center;
        margin-bottom: 20px;
    }

    .step-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background-color: var(--text-light);
        margin: 0 5px;
        transition: all 0.3s ease;
    }

    .step-dot.active {
        background-color: var(--primary);
        transform: scale(1.2);
    }

    .auth-form {
        display: none;
        animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateX(20px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }

    .auth-form.active {
        display: block;
    }

    /* Add these new styles for reCAPTCHA centering */
    #resend-captcha-container {
        display: none;
        margin: 20px auto;
        width: 100%;
        text-align: center;
    }

    #recaptcha-container-otp {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 0 auto;
        min-height: 78px;
        position: relative;
        z-index: 100;
        overflow: visible;
    }

    #recaptcha-container-otp > div {
        margin: 0 auto;
        overflow: visible;
    }

    #recaptcha-container-otp iframe {
        position: relative;
        z-index: 102;
        pointer-events: auto !important;
    }

    #recaptcha-container {
        margin: 20px 0; 
        display: flex; 
        justify-content: center;
        min-height: 78px;
        position: relative;
        z-index: 100;
        width: 100%;
        overflow: visible;
    }

    #recaptcha-container > div {
        margin: 0 auto;
        overflow: visible;
    }

    #recaptcha-container iframe {
        position: relative;
        z-index: 102;
        pointer-events: auto !important;
    }

    .password-container {
        position: relative;
        width: 100%;
    }
    
    .password-toggle {
        position: absolute;
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
        cursor: pointer;
        color: var(--text-light);
        font-size: 18px;
        opacity: 0.7;
        transition: all 0.3s ease;
    }
    
    .password-toggle:hover {
        opacity: 1;
    }
    
    .password-toggle.visible {
        color: var(--primary);
    }
    </style>
  <style>
    body.loading * {
      pointer-events: none !important;
    }
    body.loading #loadingOverlay {
      pointer-events: all !important;
    }
    .spinner {
      width: 48px;
      height: 48px;
      border: 6px solid #ccc;
      border-top: 6px solid #8a6d3b;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="loadingOverlay" style="
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    width: 100vw; height: 100vh;
    background: #fff;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: opacity 0.3s;
  ">
    <div class="spinner"></div>
  </div>
  <!-- Share Popup -->
  <div class="share-popup" id="sharePopup">
    <div class="share-card">
      <div class="close-popup" onclick="closeSharePopup()">×</div>
      <div class="medal-icon">🎯</div>
      <div class="share-title">Congratulations!</div>
      <div class="share-text">You've completed Episode 1! Share your achievement with friends and inspire them to join the reading adventure.</div>
      <button class="share-button" onclick="shareToWhatsApp()">
        <span>Share on WhatsApp</span>
        <span>💬</span>
      </button>
    </div>
  </div>

  <!-- Add this after the share popup div -->
  <div class="prompt-container" id="promptContainer">
    <div class="prompt-content">
      <div class="prompt-message" id="promptMessage"></div>
      <button class="prompt-button" onclick="closePrompt()">OK</button>
    </div>
  </div>

  <!-- Login/Signup Page -->
  <div id="auth-page" class="container">
    <div class="logo">
      <h1>word360</h1>
    </div>
    
    <div class="auth-container">
      <div class="auth-tabs">
        <div class="auth-tab active" onclick="switchTab('login')">Login</div>
        <div class="auth-tab" onclick="switchTab('signup')">Sign Up</div>
      </div>
      
      <div id="login-form" class="auth-form active">
        <div class="form-group">
          <label for="login-phone">Phone Number</label>
          <div class="phone-input-container">
            <select id="login-country-code" class="country-code">
              <option value="+91">+91 (India)</option>
              <option value="+1">+1 (US/Canada)</option>
              <option value="+44">+44 (UK)</option>
              <option value="+61">+61 (Australia)</option>
            </select>
            <input type="tel" id="login-phone" placeholder="Enter your phone number" pattern="[0-9]{10}" autocomplete="tel">
          </div>
        </div>
        <div class="form-group">
          <label for="login-password">Password <span style="color:var(--danger);">*</span></label>
          <div class="password-container">
            <input type="password" id="login-password" placeholder="Enter your password" autocomplete="current-password">
            <span class="password-toggle" onclick="togglePasswordVisibility('login-password', this)">👁️</span>
          </div>
          <div style="margin-top: 5px; text-align: right;">
            <a href="#" onclick="forgotPassword()" style="color: var(--primary); font-size: 14px; text-decoration: none;">Forgot Password?</a>
          </div>
        </div>
        <button class="ripple" onclick="login()">Let's Read!</button>
      </div>
        
      <div id="signup-form" class="auth-form">
        <div class="form-group">
          <label for="signup-phone">Phone Number</label>
          <div class="phone-input-container">
            <select id="country-code" class="country-code">
              <option value="+91">+91 (India)</option>
              <option value="+1">+1 (US/Canada)</option>
              <option value="+44">+44 (UK)</option>
              <option value="+61">+61 (Australia)</option>
            </select>
            <input type="tel" id="signup-phone" placeholder="Enter your phone number" pattern="[0-9]{10}">
          </div>
        </div>
        <!-- reCAPTCHA container - improved with better styling -->
        <div id="recaptcha-container" style="margin: 20px 0; display: flex; justify-content: center; min-height: 78px; position: relative; z-index: 10;"></div>
        <div style="text-align: center; margin-top: 15px;">
          <button class="ripple" id="manual-send-otp-btn" onclick="attemptSendOTP()">Send OTP</button>
        </div>
      </div>

      <!-- OTP Verification Form -->
      <div id="otp-form" class="auth-form">
        <div class="form-group">
          <label for="otp-input">Enter OTP</label>
          <input type="text" id="otp-input" placeholder="Enter 6-digit OTP" maxlength="6" pattern="[0-9]{6}">
        </div>
        <div class="otp-timer" id="otp-timer">Time remaining: 30s</div>
        <button class="ripple" onclick="verifyOTP()">Verify OTP</button>
        <button class="ripple resend-btn" id="resend-otp" onclick="showResendCaptcha()" disabled>Resend OTP</button>
        <div id="resend-captcha-container" style="display: none;">
          <div id="recaptcha-container-otp"></div>
        </div>
      </div>

      <!-- Step 1: Name -->
      <div id="signup-step-1" class="auth-form">
        <div class="form-group">
          <label for="signup-name">What's your name?</label>
          <input type="text" id="signup-name" placeholder="Enter your name">
        </div>
        <button class="ripple" onclick="nextStep(1)">Next</button>
      </div>

      <!-- Step 2: Age -->
      <div id="signup-step-2" class="auth-form">
        <div class="form-group">
          <label for="signup-age">How old are you?</label>
          <input type="number" id="signup-age" placeholder="Enter your age">
        </div>
        <button class="ripple" onclick="nextStep(2)">Next</button>
        <button class="ripple back-btn" onclick="prevStep(2)">Back</button>
      </div>

      <!-- Step 3: Password -->
      <div id="signup-step-3" class="auth-form">
        <div class="form-group">
          <label for="signup-password">Create a Password <span style="color:var(--danger);">*</span></label>
          <div class="password-container">
            <input type="password" id="signup-password" placeholder="Create a secure password (min 6 characters)" minlength="6" autocomplete="new-password">
            <span class="password-toggle" onclick="togglePasswordVisibility('signup-password', this)">👁️</span>
          </div>
          <div id="password-strength" style="margin-top: 5px; font-size: 12px; color: var(--text-light);">
            Password must be at least 6 characters
          </div>
        </div>
        <button class="ripple" onclick="completeRegistration()">Complete Registration</button>
        <button class="ripple back-btn" onclick="prevStep(3)">Back</button>
      </div>
    </div>
  </div>
  
  <!-- Episodes Page -->
  <div id="episodes-page" class="container">
    <div class="logo">
      <h1>word 360</h1>
    </div>
    
    <h2 style="text-align: center; margin: 20px 0; color: var(--primary); font-weight: 800;">My Reading Journey</h2>
    
    <div class="progress-container">
      <div class="progress-bar" style="width: 100%;"></div>
    </div>
    
    <p style="text-align: center; margin-bottom: 20px; color: var(--text-light);">All episodes available!</p>
    
    <div class="episodes-container">
      <!-- Episode 1 -->
      <div class="episode-card" onclick="window.location.href='monologue/monologue1.html?episode=1'">
        <div class="episode-number">1</div>
        <div class="episode-content">
          <div class="episode-title">Call from Stranger</div>
        </div>
        <div class="episode-status available">PLAY</div>
        <div class="episode-badge"></div>
      </div>
      
      <!-- Episode need to change2 --> 
      <div class="episode-card" onclick="window.location.href='episode2/mono2.html?episode=2'">
        <div class="episode-number">2</div>
        <div class="episode-content">
          <div class="episode-title">New City</div>
        </div>
        <div class="episode-status available">PLAY</div>
      </div>
      
      <!-- Episode 3 -->
      <div class="episode-card" onclick="window.location.href='monologue/monologue1.html?episode=3'">
        <div class="episode-number">3</div>
        <div class="episode-content">
          <div class="episode-title">Back to Work: The Return</div>
        </div>
        <div class="episode-status available">PLAY</div>
      </div>

      <!-- Episode 4 need to change -->
      <div class="episode-card" onclick="window.location.href='episode4/mono4.html?episode=4'">
        <div class="episode-number">4</div>
        <div class="episode-content">
          <div class="episode-title">Tools of the Trade</div>
        </div>
        <div class="episode-status available">PLAY</div>
      </div>

      <!-- Episode 5 -->
      <div class="episode-card" onclick="window.location.href='monologue/monologue1.html?episode=5'">
        <div class="episode-number">5</div>
        <div class="episode-content">
          <div class="episode-title">Whispers of Lightning</div>
        </div>
        <div class="episode-status available">PLAY</div>
      </div>
      
      <!-- Coming Soon Announcement -->
      <div class="episode-card announcement" style="background-color: rgba(99, 102, 241, 0.1); cursor: default; justify-content: center;">
        <div style="text-align: center;">
          <div style="color: var(--primary); font-size: 18px; font-weight: bold;">More Adventures Coming Soon!</div>
          <div style="color: var(--text-light); font-size: 14px; margin-top: 5px;">Stay tuned for new episodes</div>
        </div>
      </div>
    </div>

    <!-- Action Buttons -->
    <div class="action-buttons">
      <button class="action-button logout" onclick="logout()" title="Logout">
        <span class="icon">⇥</span>
        <span class="label">Logout</span>
      </button>
      <button class="action-button share" onclick="shareToWhatsApp()" title="Share on WhatsApp">
        <span class="icon">⤴</span>
        <span class="label">Share</span>
      </button>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-analytics-compat.js"></script>

  <!-- Add reCAPTCHA script -->
  <script src="https://www.google.com/recaptcha/api.js"></script>
  
  <script>
    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyDO7cACg6BNA8KiYvMhoxonDxCSKBTgwiE",
      authDomain: "yevvolearn.firebaseapp.com",
      projectId: "yevvolearn",
      storageBucket: "yevvolearn.firebasestorage.app",
      messagingSenderId: "114822749369",
      appId: "1:114822749369:web:599d567dd36e3ce7870f68",
      measurementId: "G-9V2E5C1M9V"
    };
    
    // Initialize Firebase
    if (!firebase.apps.length) {
    firebase.initializeApp(firebaseConfig);
        firebase.analytics();
    }

    const auth = firebase.auth();
    const db = firebase.firestore();

    // Add these variables at the top of your script
    let otpTimer;
    let otpTimeLeft = 60;
    let verificationId = null;
    let signupData = null;
    let recaptchaVerifier = null;
    let recaptchaWidgetId = null;
    let resendAttempts = 0;
    let isRegistrationInProgress = false;
    const MAX_RESEND_ATTEMPTS = 3; // Maximum number of resend attempts allowed

    // Add test phone numbers for development
    const TEST_PHONE_NUMBERS = {
        'US': '+16505551234',
        'India': '+919876543210',
        'UK': '+447911123456'
    };

    // Initialize reCAPTCHA
    function initializeRecaptcha() {
        return new Promise((resolve, reject) => {
            try {
                console.log('Starting reCAPTCHA initialization...');
                
                // If reCAPTCHA is already initialized and valid, clear it
                if (recaptchaVerifier) {
                    console.log('Clearing existing reCAPTCHA');
                    recaptchaVerifier.clear();
                    recaptchaVerifier = null;
                }

                // Clear the container
                const container = document.getElementById('recaptcha-container');
                if (!container) {
                    console.error('reCAPTCHA container not found');
                    throw new Error('reCAPTCHA container not found');
                }
                console.log('Clearing reCAPTCHA container...');
                container.innerHTML = '';

                // Create new reCAPTCHA verifier
                console.log('Creating new reCAPTCHA verifier...');
                recaptchaVerifier = new firebase.auth.RecaptchaVerifier('recaptcha-container', {
                    'size': 'normal',
                    'callback': async (response) => {
                        console.log('reCAPTCHA verified successfully');
                        try {
                            // Automatically trigger sendOTP when CAPTCHA is solved
                            await sendOTP(response);
                        resolve();
                        } catch (error) {
                            console.error('Error in CAPTCHA callback:', error);
                            showPrompt('Error sending OTP. Please try again.');
                            reject(error);
                        }
                    },
                    'expired-callback': () => {
                        console.log('reCAPTCHA expired');
                        showPrompt('CAPTCHA expired. Please verify again.');
                        // Reinitialize on expiry
                        initializeRecaptcha().catch(console.error);
                    }
                });

                // Render the reCAPTCHA
                console.log('Rendering reCAPTCHA...');
                recaptchaVerifier.render().then(function(widgetId) {
                    recaptchaWidgetId = widgetId;
                    console.log('reCAPTCHA rendered successfully with widget ID:', widgetId);
                }).catch(function(error) {
                    console.error('reCAPTCHA render error:', error);
                    reject(error);
                });
            } catch (error) {
                console.error('reCAPTCHA initialization error:', error);
                reject(error);
            }
        });
    }

    // Add this function for phone number validation
    function validatePhoneNumber(phoneNumber) {
        // Remove any non-digit characters
        const cleanNumber = phoneNumber.replace(/\D/g, '');
        
        // Check if it's exactly 10 digits
        if (cleanNumber.length !== 10) {
            return {
                isValid: false,
                message: `Please enter exactly 10 digits. You entered ${cleanNumber.length} digits.`
            };
        }
        
        // Check if it starts with valid digits (for example, not 0)
        if (cleanNumber.startsWith('0')) {
            return {
                isValid: false,
                message: 'Phone number cannot start with 0'
            };
        }
        
        return {
            isValid: true,
            cleanNumber
        };
    }

    // Add this after Firebase initialization
    const STORAGE_KEYS = {
        PHONE: 'auth_phone_number',
        COUNTRY_CODE: 'auth_country_code'
    };

    // Add this function after Firebase initialization
    async function checkPhoneRegistrationStatus(formattedPhone) {
        try {
            console.log('Checking registration status for:', formattedPhone);
            
            // First check for completed registrations
            const completedRegistration = await db.collection('userProgress')
                .where('phone', '==', formattedPhone)
                .where('registrationComplete', '==', true)
                .limit(1)
                .get();

            if (!completedRegistration.empty) {
                return {
                    isRegistered: true,
                    status: 'registered',
                    userData: completedRegistration.docs[0].data(),
                    message: 'Phone number is already registered'
                };
            }

            // Check for pending registrations
            const pendingRegistration = await db.collection('userProgress')
                .where('phone', '==', formattedPhone)
                .where('registrationComplete', '==', false)
                .limit(1)
                .get();
        
            if (!pendingRegistration.empty) {
                // Get the timestamp of the pending registration
                const pendingData = pendingRegistration.docs[0].data();
                const pendingTimestamp = pendingData.createdAt?.toDate() || new Date();
                const now = new Date();
                const timeDiff = now - pendingTimestamp;
                const PENDING_TIMEOUT = 10 * 60 * 1000; // 10 minutes in milliseconds

                // If pending registration is older than 10 minutes, delete it
                if (timeDiff > PENDING_TIMEOUT) {
                    await pendingRegistration.docs[0].ref.delete();
                    return {
                        isRegistered: false,
                        status: 'new',
                        message: null
                    };
        }

                return {
                    isRegistered: false,
                    status: 'pending',
                    message: 'Registration is pending. Please wait a few minutes before trying again.'
                };
            }

            // No registration found
            return {
                isRegistered: false,
                status: 'new',
                message: null
            };

        } catch (error) {
            console.error('Error checking phone registration:', error);
            throw new Error('Failed to check phone registration status');
        }
    }

    // Update sendOTP function to use the new check
    async function sendOTP(captchaResponse = null) {
        console.log('Starting sendOTP process...', { hasCaptchaResponse: !!captchaResponse });

        // For backwards compatibility - now we prefer manual button click
        if (!captchaResponse) {
            console.log('No CAPTCHA response provided, deferring to manual button');
            return;
        }

        // The rest of the function is kept for backward compatibility
        // but we now prefer the manual attemptSendOTP() function
        const countryCode = document.getElementById('country-code')?.value || '';
        const phoneInput = document.getElementById('signup-phone');
        const phoneNumber = phoneInput?.value || '';
        
        console.log('Phone details:', { countryCode, phoneNumber });

        // Validate phone number
        const validation = validatePhoneNumber(phoneNumber);
        if (!validation.isValid) {
            showPrompt(validation.message);
            if (phoneInput) {
                phoneInput.value = '';
                phoneInput.style.borderColor = 'var(--danger)';
                phoneInput.focus();
            }
            return;
        }

        const formattedPhone = `${countryCode}${validation.cleanNumber}`;
        console.log('Formatted phone:', formattedPhone);

        try {
            // Check registration status
            const registrationStatus = await checkPhoneRegistrationStatus(formattedPhone);
            
            if (registrationStatus.isRegistered) {
                showPrompt('This phone number is already registered. Please login instead.');
                switchTab('login');
                return;
            }

            if (registrationStatus.status === 'pending') {
                showPrompt(registrationStatus.message);
                return;
                //the transition will help use in t
            }

            // Store phone data in signupData
            signupData = {
                phone: formattedPhone,
                phoneNumber: validation.cleanNumber,
                countryCode: countryCode
            };

            // Disable the send button
            const sendButton = document.getElementById('manual-send-otp-btn') || document.querySelector('#signup-form button');
            if (sendButton) {
                sendButton.disabled = true;
                sendButton.textContent = 'Sending...';
            }

            // Send OTP using Firebase Phone Auth
            const appVerifier = recaptchaVerifier;
            console.log('Sending OTP request to Firebase...');
            
            try {
                const confirmationResult = await auth.signInWithPhoneNumber(formattedPhone, appVerifier);
                console.log('OTP sent successfully');
                verificationId = confirmationResult.verificationId;

                // Show OTP form
                document.getElementById('signup-form').classList.remove('active');
                document.getElementById('otp-form').classList.add('active');

                // Start OTP timer
                startOTPTimer();

                // Show success message
                showPrompt('OTP has been sent to your phone number.');

                LogRocket.track('OTP Sent Success', {
                    phone: formattedPhone
                });

        } catch (error) {
                console.error('Error sending OTP:', error);
                handleSendOTPError(error, phoneInput, formattedPhone);
            }
        } catch (error) {
            console.error('Error in sendOTP:', error);
            handleSendOTPError(error, phoneInput, formattedPhone);
        } finally {
            const sendButton = document.getElementById('manual-send-otp-btn') || document.querySelector('#signup-form button');
            if (sendButton) {
                sendButton.disabled = false;
                sendButton.textContent = 'Send OTP';
            }
        }
    }

    // Update the resend OTP function
    async function showResendCaptcha() {
        // Check if max attempts reached
        if (resendAttempts >= MAX_RESEND_ATTEMPTS) {
            showPrompt('Maximum resend attempts reached. Please start over.');
            return;
        }

        try {
            // Show loading state
            const resendButton = document.getElementById('resend-otp');
            if (resendButton) {
                resendButton.disabled = true;
                resendButton.textContent = 'Sending...';
            }

            // Increment resend attempts counter
            resendAttempts++;
            
            // Get stored phone data
            const storedPhone = localStorage.getItem(STORAGE_KEYS.PHONE);
            const storedCountryCode = localStorage.getItem(STORAGE_KEYS.COUNTRY_CODE);

            // If no stored phone data, try to get from signupData
            let formattedPhone;
            if (!storedPhone || !storedCountryCode) {
                if (!signupData || !signupData.phone) {
                    showPrompt('Phone number not found. Please start over.');
                    if (resendButton) {
                        resendButton.disabled = false;
                        resendButton.textContent = 'Resend OTP';
                    }
                    return;
                }
                formattedPhone = signupData.phone;
            } else {
                formattedPhone = `${storedCountryCode}${storedPhone}`;
                // Update signupData
                signupData = {
                    phone: formattedPhone,
                    phoneNumber: storedPhone,
                    countryCode: storedCountryCode
                };
            }

            // Create new reCAPTCHA verifier for resend
            if (recaptchaVerifier) {
                recaptchaVerifier.clear();
            }

            recaptchaVerifier = new firebase.auth.RecaptchaVerifier('recaptcha-container-otp', {
                'size': 'normal',
                'callback': async (response) => {
                    try {
                        // Send new OTP
                        const confirmationResult = await auth.signInWithPhoneNumber(formattedPhone, recaptchaVerifier);
                        verificationId = confirmationResult.verificationId;
            
            // Start new timer
            startOTPTimer();

                        // Update UI
                        const remainingAttempts = MAX_RESEND_ATTEMPTS - resendAttempts;
                        showPrompt(`New OTP has been sent. ${remainingAttempts} resend attempts remaining.`);

                        // Update resend button
                        if (resendButton) {
                            resendButton.textContent = `Resend OTP (${remainingAttempts} left)`;
                            resendButton.disabled = true; // Will be enabled by timer
            }

                        // Clear and hide reCAPTCHA
                        document.getElementById('recaptcha-container-otp').innerHTML = '';
                        document.getElementById('resend-captcha-container').style.display = 'none';
            
            LogRocket.track('OTP Resend Success', {
                            phone: formattedPhone,
                attemptNumber: resendAttempts,
                            remainingAttempts
                        });
                    } catch (error) {
                        handleResendError(error);
                    }
                },
                'expired-callback': () => {
                    showPrompt('CAPTCHA expired. Please try again.');
                    if (resendButton) {
                        resendButton.disabled = false;
                        resendButton.textContent = 'Resend OTP';
            }
                }
            });

            // Show the reCAPTCHA container
            const resendContainer = document.getElementById('resend-captcha-container');
            if (resendContainer) {
                resendContainer.style.display = 'block';
            }

            // Render the reCAPTCHA
            await recaptchaVerifier.render();

        } catch (error) {
            handleResendError(error);
        }
    }

    // Add helper function for resend errors
    function handleResendError(error) {
            console.error('Resend OTP error:', error);

            LogRocket.track('OTP Resend Error', {
                error: error.message,
                code: error.code,
            phone: signupData.phone,
                attemptNumber: resendAttempts
            });

        // Decrement the counter if the resend failed
        resendAttempts--;
        
        const resendButton = document.getElementById('resend-otp');
        if (resendButton) {
            resendButton.disabled = false;
            const remainingAttempts = MAX_RESEND_ATTEMPTS - resendAttempts;
            resendButton.textContent = `Resend OTP (${remainingAttempts} left)`;
        }

        // Clear reCAPTCHA container
        const container = document.getElementById('recaptcha-container-otp');
        if (container) {
            container.innerHTML = '';
        }

        // Hide reCAPTCHA container
        const resendContainer = document.getElementById('resend-captcha-container');
        if (resendContainer) {
            resendContainer.style.display = 'none';
        }

        if (error.code === 'auth/too-many-requests') {
            showPrompt('Too many attempts. Please try again later.');
        } else if (error.code === 'auth/quota-exceeded') {
            showPrompt('SMS quota exceeded. Please try again later.');
        } else {
            showPrompt(error.message || 'Failed to resend OTP. Please try again.');
        }
    }

    // Update startOTPTimer to handle resend button state
    function startOTPTimer() {
        const resendButton = document.getElementById('resend-otp');
        const timerDisplay = document.getElementById('otp-timer');
        const otpInput = document.getElementById('otp-input');
        
        // Clear any existing timer
        if (otpTimer) {
            clearInterval(otpTimer);
        }
        
        // Reset button states and input
        if (resendButton) {
        resendButton.disabled = true;
            const remainingAttempts = MAX_RESEND_ATTEMPTS - resendAttempts;
            resendButton.textContent = `Resend OTP (${remainingAttempts} left)`;
        }

        if (otpInput) {
        otpInput.disabled = false;
            otpInput.value = ''; // Clear previous OTP
        otpInput.focus();
        }
        
        // Start with 30 seconds
        otpTimeLeft = 30;
        if (timerDisplay) {
        timerDisplay.textContent = `Time remaining: ${otpTimeLeft}s`;
        }
        
        otpTimer = setInterval(() => {
            otpTimeLeft--;
            
            if (timerDisplay) {
            timerDisplay.textContent = `Time remaining: ${otpTimeLeft}s`;
            }
            
            if (otpTimeLeft <= 0) {
                clearInterval(otpTimer);
                
                if (otpInput) {
                otpInput.disabled = true;
                }
                
                // Enable resend button only if attempts remain
                if (resendAttempts < MAX_RESEND_ATTEMPTS && resendButton) {
                    resendButton.disabled = false;
                    if (timerDisplay) {
                        timerDisplay.textContent = 'OTP expired. Click Resend OTP to try again.';
                    }
                } else if (resendButton) {
                    resendButton.disabled = true;
                    resendButton.textContent = 'No more resend attempts';
                    if (timerDisplay) {
                    timerDisplay.textContent = 'Maximum resend attempts reached. Please start over.';
                }
                }
            }
        }, 1000);
    }

    // Update login function to use the new check
    async function login() {
        const countryCode = document.getElementById('login-country-code')?.value || '';
        const phoneNumber = document.getElementById('login-phone')?.value || '';
        const password = document.getElementById('login-password')?.value;

        if (!phoneNumber || !password) {
            showPrompt('Please fill in all fields');
            return;
        }

        // Validate phone number
        const validation = validatePhoneNumber(phoneNumber);
        if (!validation.isValid) {
            showPrompt(validation.message);
            return;
        }

        const formattedPhone = `${countryCode}${validation.cleanNumber}`;

        try {
            // Make sure registration is NOT in progress for login
            isRegistrationInProgress = false;
            
            // Show loading state
            const loginButton = document.querySelector('#login-form button');
            if (loginButton) {
                loginButton.disabled = true;
                loginButton.textContent = 'Logging in...';
            }

            console.log('Attempting to login with phone:', formattedPhone);
            
            // Check registration status
            const registrationStatus = await checkPhoneRegistrationStatus(formattedPhone);
            
            if (!registrationStatus.isRegistered) {
                showPrompt('No account found with this phone number. Please sign up.');
                switchTab('signup');
                return;
            }

            // Verify password
            const userData = registrationStatus.userData;
            console.log('Found user data:', { name: userData.name, phone: userData.phone, hasPassword: !!userData.password });
            
            // Compare with stored password
            const hashedPassword = btoa(password);
            
            if (userData.password !== hashedPassword) {
                console.log('Password verification failed');
                showPrompt('Incorrect password. Please try again.');
                if (loginButton) {
                    loginButton.disabled = false;
                    loginButton.textContent = "Let's Read!";
                }
                // Focus on password field for better UX
                document.getElementById('login-password').value = '';
                document.getElementById('login-password').focus();
                return;
            }

            console.log('Password verified successfully');

            // Instead of using signInAnonymously, we'll use custom auth
            // Just set authentication state in our app without Firebase Auth
            // Store auth data
            localStorage.setItem('auth_name', userData.name);
            localStorage.setItem('auth_phone', formattedPhone);
            localStorage.setItem('auth_isLoggedIn', 'true');
            if (userData.userId) {
                localStorage.setItem('auth_userId', userData.userId);
            }
            
            LogRocket.identify(formattedPhone, {
                name: userData.name,
                loginTime: new Date().toISOString()
            });
            
            LogRocket.track('Login Success', {
                phone: formattedPhone
            });
            
            // Show success message
            showPrompt('Login successful! Welcome back!');

            // Manual redirection instead of relying on auth state observer
            setTimeout(() => {
        document.getElementById('auth-page').classList.remove('visible');
        document.getElementById('episodes-page').classList.add('visible');
            checkEpisodeCompletion();
            }, 1500);

        } catch (error) {
            console.error('Login error:', error);
            showPrompt(error.message || 'Login failed. Please try again.');
        } finally {
            const loginButton = document.querySelector('#login-form button');
            if (loginButton) {
                loginButton.disabled = false;
                loginButton.textContent = "Let's Read!";
            }
      }
    }
    
    // Initialize the visibility of pages
    document.addEventListener('DOMContentLoaded', () => {
      // Show auth page by default
      document.getElementById('auth-page').classList.add('visible');
      document.getElementById('episodes-page').classList.remove('visible');
      
      // Add debugging for reCAPTCHA
      const container = document.getElementById('recaptcha-container');
      if (container) {
          // Add a debug message that will be hidden once reCAPTCHA loads
          const debugMsg = document.createElement('div');
          debugMsg.id = 'recaptcha-debug-msg';
          debugMsg.innerHTML = '<small style="color: #999;">If CAPTCHA doesn\'t appear after 5 seconds, try refreshing the page.</small>';
          debugMsg.style.textAlign = 'center';
          debugMsg.style.padding = '10px';
          container.appendChild(debugMsg);
          
          // Remove debug message once reCAPTCHA loads
          setTimeout(() => {
              if (container.querySelector('iframe')) {
                  const msg = document.getElementById('recaptcha-debug-msg');
                  if (msg) msg.style.display = 'none';
              }
          }, 5000);
      }
      
      // Initialize reCAPTCHA when the page loads
      initializeRecaptcha().catch(error => {
          console.error('Initial reCAPTCHA initialization failed:', error);
          showPrompt('Failed to load CAPTCHA. Please refresh the page and try again.');
      });
    });
    
    // Switch between login and signup tabs
    function switchTab(tab) {
      const loginTab = document.querySelector('.auth-tab:nth-child(1)');
      const signupTab = document.querySelector('.auth-tab:nth-child(2)');
      const loginForm = document.getElementById('login-form');
      const signupForm = document.getElementById('signup-form');
      const otpForm = document.getElementById('otp-form');
      const step1Form = document.getElementById('signup-step-1');
      
      cleanupAuthData();
      
      // Also reset the signup-step-1 form HTML to default state
      step1Form.innerHTML = `
        <div class="form-group">
          <label for="signup-name">What's your name?</label>
          <input type="text" id="signup-name" placeholder="Enter your name">
        </div>
        <button class="ripple" onclick="nextStep(1)">Next</button>
      `;
      
      if (tab === 'login') {
        loginTab.classList.add('active');
        signupTab.classList.remove('active');
        loginForm.classList.add('active');
        signupForm.classList.remove('active');
            otpForm.classList.remove('active');
            
            // Clear CAPTCHA if switching to login
            if (recaptchaVerifier) {
                recaptchaVerifier.clear();
                recaptchaVerifier = null;
            }
      } else {
        loginTab.classList.remove('active');
        signupTab.classList.add('active');
        loginForm.classList.remove('active');
        signupForm.classList.add('active');
            otpForm.classList.remove('active');
            
            // Initialize CAPTCHA only when switching to signup
        initializeRecaptcha().catch(error => {
            console.error('reCAPTCHA initialization failed on tab switch:', error);
        });
    }
    
        // Reset OTP-related variables
      resendAttempts = 0;
      if (otpTimer) {
          clearInterval(otpTimer);
      }
      verificationId = null;
      signupData = null;
        
        // Clear stored data when switching tabs
        localStorage.removeItem(STORAGE_KEYS.PHONE);
        localStorage.removeItem(STORAGE_KEYS.COUNTRY_CODE);
    }
    
    // Logout function
    function logout() {
        // Clear auth data from localStorage
        localStorage.removeItem('auth_name');
        localStorage.removeItem('auth_phone');
        localStorage.removeItem('auth_token');
        localStorage.removeItem('auth_isLoggedIn');
        localStorage.removeItem('auth_userId');
        localStorage.removeItem('show_episodes_page');
        localStorage.removeItem(STORAGE_KEYS.PHONE);
        localStorage.removeItem(STORAGE_KEYS.COUNTRY_CODE);

        // Clear signup data
        signupData = null;
        verificationId = null;
        isRegistrationInProgress = false;

        // Log analytics
        LogRocket.track('Logout Success');
        
        // Reset UI
        document.getElementById('episodes-page').classList.remove('visible');
        document.getElementById('auth-page').classList.add('visible');
        
        // Reset forms
        document.getElementById('login-form').reset();
        document.getElementById('signup-form').reset();
        
        // Hide all forms except login
        document.getElementById('login-form').classList.add('active');
        document.getElementById('signup-form').classList.remove('active');
        document.getElementById('otp-form').classList.remove('active');
        document.getElementById('signup-step-1').classList.remove('active');
        document.getElementById('signup-step-2').classList.remove('active');
        document.getElementById('signup-step-3').classList.remove('active');
        
        // Update tabs
        document.querySelector('.auth-tab:nth-child(1)').classList.add('active');
        document.querySelector('.auth-tab:nth-child(2)').classList.remove('active');
        
        // Sign out from Firebase
        firebase.auth().signOut().catch((error) => {
            console.error('Firebase logout error:', error);
            LogRocket.track('Logout Error', {
          error: error.message
        });
        });
    }

    // Update the action button click handler
    document.querySelector('.action-button.logout').onclick = function(e) {
        e.preventDefault();
        logout();
    };

    // Show message function
    function showMessage(message, type) {
      alert(message);
    }

    // Share functionality
    function showSharePopup() {
      document.getElementById('sharePopup').classList.add('active');
    }

    function closeSharePopup() {
      document.getElementById('sharePopup').classList.remove('active');
    }

    function shareToWhatsApp() {
      const shareText = "🎉 I just completed Episode 1 of Detective Ferret's Reading Adventure! Join me in this exciting journey to improve reading skills. Try it now: [Your App URL]";
      const whatsappUrl = `https://wa.me/?text=${encodeURIComponent(shareText)}`;
      window.open(whatsappUrl, '_blank');
    }

    // Update the checkEpisodeCompletion function
    async function checkEpisodeCompletion() {
        // Check if user is logged in via our custom auth
        const isLoggedIn = localStorage.getItem('auth_isLoggedIn') === 'true';
        const phone = localStorage.getItem('auth_phone');
        
        if (!isLoggedIn || !phone) {
            console.log('No logged in user found, skipping episode completion check');
        return;
      }

        console.log('Checking episode completion for user with phone:', phone);
        
        // Get all episode cards
        const episodeCards = document.querySelectorAll('.episode-card:not(.announcement)');
        console.log('Found episode cards:', episodeCards.length);
        
        try {
            // Get unlock time from localStorage or Firestore
            let nextEpisodeUnlock = parseInt(localStorage.getItem('next_episode_unlock')) || 0;
            let completedEpisodes = [];
            
            // Try to find user data by phone
            const userQuery = await db.collection('userProgress')
                .where('phone', '==', phone)
                .limit(1)
                .get();
            
            if (userQuery.empty) {
                console.log('No user progress found for phone:', phone);
                // Initialize empty progress for new users
                episodeCards.forEach((card, index) => {
                    // First clear any existing classes
                    card.classList.remove('completed', 'next', 'locked');
                    
                    if (index === 0) {
                        // First episode is next
                        card.classList.add('next');
                        const statusElement = card.querySelector('.episode-status');
                        statusElement.textContent = 'PLAY';
                        statusElement.classList.add('blink-text');
                        // Handle special URL for episode 2 and 4
                        if (index + 1 === 2) {
                            card.onclick = () => window.location.href = `episode2/mono2.html?episode=${index + 1}`;
                        } else if (index + 1 === 4) {
                            card.onclick = () => window.location.href = `episode4/mono4.html?episode=${index + 1}`;
                        } else {
                            card.onclick = () => window.location.href = `monologue/monologue1.html?episode=${index + 1}`;
                        }
                    } else {
                        // All other episodes are locked
                        card.classList.add('locked');
                        card.querySelector('.episode-status').textContent = 'LOCKED';
                        card.onclick = null;
                    }
                });
                
                // Update progress bar and text for new users
                const progressBar = document.querySelector('.progress-bar');
                progressBar.style.width = '0%';
                const progressText = document.querySelector('.progress-container + p');
                progressText.textContent = 'Start your reading journey!';
                return;
            }
            
            // Get user data
            const userData = userQuery.docs[0].data();
            completedEpisodes = userData.completedEpisodes || [];
            
            console.log('Retrieved user progress:', {
                name: userData.name,
                completedEpisodes: completedEpisodes
            });
            
                let nextEpisodeFound = false;
                
                // Update episode cards
                episodeCards.forEach((card, index) => {
                    const episodeNumber = index + 1;
                    console.log(`Processing episode ${episodeNumber}`);
                    
                    // Remove all classes first
                    card.classList.remove('completed', 'next', 'locked');
                    
                    // Mark completed episodes
                if (completedEpisodes.includes(episodeNumber)) {
                        console.log(`Episode ${episodeNumber} is completed`);
                        card.classList.add('completed');
                        card.querySelector('.episode-status').textContent = 'COMPLETED';
                    // Special handling for episodes 2 and 4
                    if (episodeNumber === 2) {
                        card.onclick = () => window.location.href = `episode2/mono2.html?episode=${episodeNumber}`;
                    } else if (episodeNumber === 4) {
                        card.onclick = () => window.location.href = `episode4/mono4.html?episode=${episodeNumber}`;
                    } else {
                        card.onclick = () => window.location.href = `monologue/monologue1.html?episode=${episodeNumber}`;
                    }
                    }
                    // Find next incomplete episode
                    else if (!nextEpisodeFound && 
                    (episodeNumber === 1 || completedEpisodes.includes(episodeNumber - 1))) {
                        console.log(`Episode ${episodeNumber} is next`);
                        card.classList.add('next');
                    const statusElement = card.querySelector('.episode-status');
                    statusElement.textContent = 'PLAY';
                    statusElement.classList.add('blink-text');
                    // Special handling for episodes 2 and 4
                    if (episodeNumber === 2) {
                        card.onclick = () => window.location.href = `episode2/mono2.html?episode=${episodeNumber}`;
                    } else if (episodeNumber === 4) {
                        card.onclick = () => window.location.href = `episode4/mono4.html?episode=${episodeNumber}`;
                    } else {
                        card.onclick = () => window.location.href = `monologue/monologue1.html?episode=${episodeNumber}`;
                    }
                        nextEpisodeFound = true;
                    }
                    // Lock remaining episodes
                    else {
                        console.log(`Episode ${episodeNumber} is locked`);
                        card.classList.add('locked');
                        card.querySelector('.episode-status').textContent = 'LOCKED';
                        card.onclick = null;
                    }
                });

                // Update progress bar
                const progressBar = document.querySelector('.progress-bar');
            const progressPercentage = (completedEpisodes.length / 5) * 100;
                progressBar.style.width = `${progressPercentage}%`;
                console.log(`Progress: ${progressPercentage}%`);

                // Update progress text
                const progressText = document.querySelector('.progress-container + p');
            if (completedEpisodes.length === 5) {
                    progressText.textContent = 'All episodes completed! 🎉';
                } else {
                progressText.textContent = `${completedEpisodes.length} out of 5 episodes completed`;
                }
        } catch (error) {
            console.error('Error checking episode completion:', error);
        }
    }
    
    // Add back the auth state observer
    // Update the auth state observer to be more defensive
    auth.onAuthStateChanged((user) => {
      console.log('Firebase auth state changed - User:', user?.uid || 'none', 'isRegistrationInProgress:', isRegistrationInProgress);
      
      // We're now using custom auth, so we'll only use this for registration flow
      if (user && isRegistrationInProgress) {
          console.log('Auth state changed during registration, not redirecting');
          // Force the auth page to be visible during registration
          document.getElementById('auth-page').classList.add('visible');
          document.getElementById('episodes-page').classList.remove('visible');
      }
    });
    
    // Add a custom auth checker that runs on page load
    document.addEventListener('DOMContentLoaded', () => {
      // Show auth page by default
      document.getElementById('auth-page').classList.add('visible');
      
      // Check for show_episodes_page flag or URL fragment - this is the priority
      const showEpisodesPage = localStorage.getItem('show_episodes_page') === 'true' || window.location.hash === '#episodes';
      
      // Check if user is logged in via our custom auth
      const isLoggedIn = localStorage.getItem('auth_isLoggedIn') === 'true';
      const phone = localStorage.getItem('auth_phone');

      // Initialize reCAPTCHA when the page loads (only if not showing episodes)
      if (!showEpisodesPage && !isLoggedIn) {
        initializeRecaptcha().catch(error => {
            console.error('Initial reCAPTCHA initialization failed:', error);
        });
      }
      
      // If coming from episode completion or URL has #episodes, show episodes page immediately
      if (showEpisodesPage) {
        console.log('Found show_episodes_page flag or #episodes fragment, showing episodes page directly');
        document.getElementById('auth-page').classList.remove('visible');
        document.getElementById('episodes-page').classList.add('visible');
        localStorage.removeItem('show_episodes_page'); // Clear the flag once used
        
        // Call checkEpisodeCompletion with a short delay to ensure UI is updated
        if (isLoggedIn && phone) {
          checkEpisodeCompletion();
        }
        return;
      }
      
      // Normal flow - only redirect to episodes page if properly authenticated
      if (isLoggedIn && phone && !isRegistrationInProgress) {
        console.log('User is logged in via custom auth, redirecting to episodes page');
        document.getElementById('auth-page').classList.remove('visible');
        document.getElementById('episodes-page').classList.add('visible');
        checkEpisodeCompletion();
        } else {
        // Clear any potentially invalid auth data to prevent unwanted redirects
        localStorage.removeItem('show_episodes_page');
        console.log('User is not logged in, showing auth page');
    }
    });

    // Add these functions
    function showPrompt(message) {
        const promptContainer = document.getElementById('promptContainer');
        const promptMessage = document.getElementById('promptMessage');
        
        if (promptContainer && promptMessage) {
            promptMessage.textContent = message;
            promptContainer.style.display = 'flex';
            
            // Focus on name input if showing registration prompt
            if (message.includes('enter your name')) {
                const nameInput = document.getElementById('signup-name');
                if (nameInput) {
                    nameInput.focus();
                }
            }
        }
    }

    function closePrompt() {
        const promptContainer = document.getElementById('promptContainer');
        if (promptContainer) {
            promptContainer.style.display = 'none';
        }
    }

    // Add new function to handle showing reCAPTCHA for resend
    async function showResendCaptcha() {
        // Check if max attempts reached
        if (resendAttempts >= MAX_RESEND_ATTEMPTS) {
            showPrompt('Maximum resend attempts reached. Please start over.');
            return;
        }

        try {
            // Show loading state
            const resendButton = document.getElementById('resend-otp');
            if (resendButton) {
                resendButton.disabled = true;
                resendButton.textContent = 'Sending...';
            }

            // Increment resend attempts counter
            resendAttempts++;
            
            // Get the stored phone number from signupData
            if (!signupData || !signupData.phone) {
                showPrompt('Error: Phone number not found. Please start over.');
                return;
            }

            // Create new reCAPTCHA verifier for resend
        if (recaptchaVerifier) {
            recaptchaVerifier.clear();
            }

        recaptchaVerifier = new firebase.auth.RecaptchaVerifier('recaptcha-container-otp', {
            'size': 'normal',
                'callback': async (response) => {
                    try {
                        // Send new OTP
                        const confirmationResult = await auth.signInWithPhoneNumber(signupData.phone, recaptchaVerifier);
                        verificationId = confirmationResult.verificationId;

                        // Start new timer
                        startOTPTimer();

                        // Update UI
                        const remainingAttempts = MAX_RESEND_ATTEMPTS - resendAttempts;
                        showPrompt(`New OTP has been sent. ${remainingAttempts} resend attempts remaining.`);

                        // Update resend button
                        if (resendButton) {
                            resendButton.textContent = `Resend OTP (${remainingAttempts} left)`;
                            resendButton.disabled = true; // Will be enabled by timer
                        }

                        // Clear and hide reCAPTCHA
                        document.getElementById('recaptcha-container-otp').innerHTML = '';
                        document.getElementById('resend-captcha-container').style.display = 'none';

                        LogRocket.track('OTP Resend Success', {
                            phone: signupData.phone,
                            attemptNumber: resendAttempts,
                            remainingAttempts
                        });
                    } catch (error) {
                        handleResendError(error);
                    }
            },
            'expired-callback': () => {
                    showPrompt('CAPTCHA expired. Please try again.');
                    if (resendButton) {
                        resendButton.disabled = false;
                        resendButton.textContent = 'Resend OTP';
                    }
                }
            });

            // Show the reCAPTCHA container
        const resendContainer = document.getElementById('resend-captcha-container');
            if (resendContainer) {
        resendContainer.style.display = 'block';
            }
        
            // Render the reCAPTCHA
            await recaptchaVerifier.render();

        } catch (error) {
            handleResendError(error);
        }
    }

    // Add these functions to your existing script
    function nextStep(currentStep) {
        const currentStepElem = document.getElementById(`signup-step-${currentStep}`);
        const nextStepElem = document.getElementById(`signup-step-${currentStep + 1}`);
        
        // Validate current step
        if (!validateStep(currentStep)) {
            return;
        }

        currentStepElem.classList.remove('active');
        nextStepElem.classList.add('active');
        
        // Log step progression
        LogRocket.track('Registration Step Completed', {
            step: currentStep,
            nextStep: currentStep + 1
        });
    }

    function prevStep(currentStep) {
        const currentStepElem = document.getElementById(`signup-step-${currentStep}`);
        const prevStepElem = document.getElementById(`signup-step-${currentStep - 1}`);
        
        currentStepElem.classList.remove('active');
        prevStepElem.classList.add('active');
    }

    function validateStep(step) {
        switch(step) {
            case 1:
                const name = document.getElementById('signup-name').value.trim();
                if (!name) {
                    showPrompt('Please enter your name');
                    return false;
                }
                return true;
            
            case 2:
                const age = document.getElementById('signup-age').value;
                if (!age || age < 5 || age > 100) {
                    showPrompt('Please enter a valid age between 5 and 100');
                    return false;
                }
                return true;
            
            default:
                return true;
        }
    }

    async function completeRegistration() {
        const name = document.getElementById('signup-name')?.value?.trim();
        const password = document.getElementById('signup-password')?.value;

        // Validate fields
        if (!name) {
            showPrompt('Please enter your name');
            document.getElementById('signup-name').focus();
            return;
        }

        if (!password || password.length < 6) {
            showPrompt('Please enter a secure password (at least 6 characters)');
            document.getElementById('signup-password').focus();
            return;
        }

        try {
            // Show loading state
            const registerButton = document.querySelector('#signup-step-1 button');
            if (registerButton) {
                registerButton.disabled = true;
                registerButton.textContent = 'Creating your account...';
            }

            // Double check if phone is already registered
            const registrationStatus = await checkPhoneRegistrationStatus(signupData.phone);
            
            if (registrationStatus.isRegistered) {
                showPrompt('This phone number is already registered. Please login instead.');
                switchTab('login');
                return;
            }

            console.log('Completing registration for:', { phone: signupData.phone, name });

            // Hash the password - in production, use a more secure hashing method
            const hashedPassword = btoa(password);
            
            // Store the raw password temporarily in signupData for potential login
            signupData.password = password;

            // Create user document in Firestore using current user's UID when available
            const userId = firebase.auth().currentUser?.uid || null;
            const userDocRef = userId ? db.collection('userProgress').doc(userId) : db.collection('userProgress').doc();
            
            console.log('Creating user document with ID:', userDocRef.id);
            
            await userDocRef.set({
                phone: signupData.phone,
                name: name,
                password: hashedPassword,
                registrationComplete: true,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                userId: userId,
                completedEpisodes: []
            });

            console.log('User document created in Firestore');

            // Store auth data in localStorage (no password stored in localStorage)
            localStorage.setItem('auth_name', name);
            localStorage.setItem('auth_phone', signupData.phone);
            localStorage.setItem('auth_userId', userDocRef.id);
            localStorage.setItem('auth_isLoggedIn', 'true');  // Explicitly set login flag

            LogRocket.identify(signupData.phone, {
                name: name,
                signupTime: new Date().toISOString()
            });

            LogRocket.track('Registration Complete', {
                phone: signupData.phone,
                name: name,
                userId: userDocRef.id
            });

            // Show success message
            showPrompt('Registration successful! Welcome to your reading journey!');
            
            // Clean up sensitive data
            signupData.password = null;
            signupData = null;
            verificationId = null;

            // Wait for a bit to let the user see the success message
            setTimeout(() => {
                // Now that registration is complete, set flag to allow redirect
                isRegistrationInProgress = false;
                console.log('Registration completed, setting isRegistrationInProgress to false');
                
                // Manually trigger the redirect to episodes page
                document.getElementById('auth-page').classList.remove('visible');
                document.getElementById('episodes-page').classList.add('visible');
                checkEpisodeCompletion();
                console.log('Redirected to episodes page after registration');
            }, 1500);

        } catch (error) {
            console.error('Registration error:', error);
            showPrompt(error.message || 'Registration failed. Please try again.');
            
            // Re-enable register button
            const registerButton = document.querySelector('#signup-step-1 button');
            if (registerButton) {
                registerButton.disabled = false;
                registerButton.textContent = 'Complete Registration';
            }
        }
    }

    // Add input validation as user types
    document.addEventListener('DOMContentLoaded', function() {
        const signupPhone = document.getElementById('signup-phone');
        const loginPhone = document.getElementById('login-phone');
        
        if (signupPhone) {
            signupPhone.addEventListener('input', function(e) {
                // Remove any non-digit characters as they type
                let value = e.target.value.replace(/\D/g, '');
                
                // Limit to 10 digits
                if (value.length > 10) {
                    value = value.slice(0, 10);
                }
                
                // Update the input value
                e.target.value = value;
                
                // Visual feedback
                if (value.length === 10) {
                    e.target.style.borderColor = 'var(--success)';
                } else {
                    e.target.style.borderColor = '#E5E7EB';
                }
            });
        }
        
        if (loginPhone) {
            loginPhone.addEventListener('input', function(e) {
                // Remove any non-digit characters as they type
                let value = e.target.value.replace(/\D/g, '');
                
                // Limit to 10 digits
                if (value.length > 10) {
                    value = value.slice(0, 10);
                }
                
                // Update the input value
                e.target.value = value;
                
                // Visual feedback
                if (value.length === 10) {
                    e.target.style.borderColor = 'var(--success)';
                } else {
                    e.target.style.borderColor = '#E5E7EB';
                }
            });
        }
    });

    // Add this cleanup function
    function cleanupAuthData() {
        // Clear localStorage
        localStorage.removeItem(STORAGE_KEYS.PHONE);
        localStorage.removeItem(STORAGE_KEYS.COUNTRY_CODE);
        localStorage.removeItem('auth_name');
        localStorage.removeItem('auth_phone');
        localStorage.removeItem('auth_token');

        // Clear signup data
        signupData = null;
        verificationId = null;

        // Reset form fields
        const phoneInputs = ['signup-phone', 'login-phone'];
        phoneInputs.forEach(id => {
            const input = document.getElementById(id);
            if (input) {
                input.value = '';
                input.style.borderColor = '#E5E7EB';
            }
        });
    }

    // Update logout function
    function logout() {
        cleanupAuthData();

        // Sign out from Firebase
        firebase.auth().signOut().then(() => {
            LogRocket.track('Logout Success');
            
            // Reset UI
            document.getElementById('episodes-page').classList.remove('visible');
            document.getElementById('auth-page').classList.add('visible');
            
            // Reset forms
            document.getElementById('login-form').reset();
            document.getElementById('signup-form').reset();
            
            // Show login form
            document.getElementById('login-form').classList.add('active');
            document.getElementById('signup-form').classList.remove('active');
            
            // Update tabs
            document.querySelector('.auth-tab:nth-child(1)').classList.add('active');
            document.querySelector('.auth-tab:nth-child(2)').classList.remove('active');
            
        }).catch((error) => {
            console.error('Logout error:', error);
            LogRocket.track('Logout Error', {
                error: error.message
            });
        });
    }

    // Update switchTab function
    function switchTab(tab) {
        const loginTab = document.querySelector('.auth-tab:nth-child(1)');
        const signupTab = document.querySelector('.auth-tab:nth-child(2)');
        const loginForm = document.getElementById('login-form');
        const signupForm = document.getElementById('signup-form');
        const otpForm = document.getElementById('otp-form');
        
        cleanupAuthData();
        
        if (tab === 'login') {
            loginTab.classList.add('active');
            signupTab.classList.remove('active');
            loginForm.classList.add('active');
            signupForm.classList.remove('active');
            otpForm.classList.remove('active');
            
            // Clear CAPTCHA if switching to login
        if (recaptchaVerifier) {
            recaptchaVerifier.clear();
            recaptchaVerifier = null;
        }
        } else {
            loginTab.classList.remove('active');
            signupTab.classList.add('active');
            loginForm.classList.remove('active');
            signupForm.classList.add('active');
            otpForm.classList.remove('active');
            
            // Initialize CAPTCHA only when switching to signup
            initializeRecaptcha().catch(error => {
                console.error('reCAPTCHA initialization failed on tab switch:', error);
            });
        }
        
        // Reset OTP-related variables
        resendAttempts = 0;
        if (otpTimer) {
            clearInterval(otpTimer);
        }
    }

    // Update auth state observer
    auth.onAuthStateChanged((user) => {
        console.log('Main auth state observer triggered - User:', user?.uid || 'none');
        
        // Check for localStorage auth - require BOTH values for proper authentication
        const isLocalStorageAuth = localStorage.getItem('auth_isLoggedIn') === 'true' && localStorage.getItem('auth_phone');
        
        // Handle Firebase authenticated user
        if (user) {
            console.log('User is signed in via Firebase Auth');
            
            // Log user data to LogRocket
            LogRocket.identify(user.email || user.phoneNumber, {
                name: user.displayName || user.email || user.phoneNumber,
                loginTime: new Date().toISOString()
            });

            // Only update UI if we're not doing registration AND valid localStorage auth is present
            if (!isRegistrationInProgress && isLocalStorageAuth) {
                document.getElementById('auth-page').classList.remove('visible');
                document.getElementById('episodes-page').classList.add('visible');
                checkEpisodeCompletion();
            } else {
                // Keep auth page visible otherwise
                document.getElementById('auth-page').classList.add('visible');
                document.getElementById('episodes-page').classList.remove('visible');
            }
        } 
        // Handle no Firebase user
        else {
            console.log('No Firebase Auth user found');
            
            // Only show episodes page if valid localStorage auth exists
            if (isLocalStorageAuth && !isRegistrationInProgress) {
                console.log('Using localStorage auth, keeping episodes page visible');
                document.getElementById('auth-page').classList.remove('visible');
                document.getElementById('episodes-page').classList.add('visible');
                checkEpisodeCompletion();
                return;
            }
            
            // Default to login page in all other cases
            console.log('No authentication found, showing auth page');
            document.getElementById('auth-page').classList.add('visible');
            document.getElementById('episodes-page').classList.remove('visible');
            
            // Reset to login form
            document.getElementById('login-form').classList.add('active');
            document.getElementById('signup-form').classList.remove('active');
            document.getElementById('otp-form').classList.remove('active');
            
            // Update tabs
            document.querySelector('.auth-tab:nth-child(1)').classList.add('active');
            document.querySelector('.auth-tab:nth-child(2)').classList.remove('active');
            
            // Clear any existing reCAPTCHA
            if (recaptchaVerifier) {
                recaptchaVerifier.clear();
                recaptchaVerifier = null;
            }
            
            // Initialize new reCAPTCHA
            initializeRecaptcha().catch(error => {
                console.error('Initial reCAPTCHA initialization failed:', error);
            });
        }
    });

    // Add this after the shareToWhatsApp function
    function forgotPassword() {
        showPrompt('To reset your password, please contact support at +917550350626');
    }

    // Add this function to handle manual OTP sending
    async function attemptSendOTP() {
        const countryCode = document.getElementById('country-code')?.value || '';
        const phoneInput = document.getElementById('signup-phone');
        const phoneNumber = phoneInput?.value || '';
        const sendButton = document.getElementById('manual-send-otp-btn');
        
        // Validate phone number
        const validation = validatePhoneNumber(phoneNumber);
        if (!validation.isValid) {
            showPrompt(validation.message);
            return;
        }
        
        // Disable button while processing
        if (sendButton) {
            sendButton.disabled = true;
            sendButton.textContent = 'Sending...';
        }
        
        try {
            // Get reCAPTCHA response
            if (!recaptchaVerifier) {
                showPrompt('CAPTCHA is not initialized. Please refresh the page and try again.');
                return;
            }
            
            const formattedPhone = `${countryCode}${validation.cleanNumber}`;
            console.log('Formatted phone for manual send:', formattedPhone);
            
            // Check registration status
            const registrationStatus = await checkPhoneRegistrationStatus(formattedPhone);
            
            if (registrationStatus.isRegistered) {
                showPrompt('This phone number is already registered. Please login instead.');
                switchTab('login');
                return;
            }
            
            if (registrationStatus.status === 'pending') {
                showPrompt(registrationStatus.message);
                return;
            }
            
            // Store phone data
            signupData = {
                phone: formattedPhone,
                phoneNumber: validation.cleanNumber,
                countryCode: countryCode
            };
            
            // Get verification response
            const recaptchaResponse = grecaptcha.getResponse(recaptchaWidgetId);
            if (!recaptchaResponse) {
                showPrompt('Please complete the CAPTCHA verification first.');
                return;
            }
            
            // Send OTP
            console.log('Sending OTP with reCAPTCHA response');
            const appVerifier = recaptchaVerifier;
            
            try {
                const confirmationResult = await auth.signInWithPhoneNumber(formattedPhone, appVerifier);
                console.log('OTP sent successfully');
                verificationId = confirmationResult.verificationId;
                
                // Show OTP form
                document.getElementById('signup-form').classList.remove('active');
                document.getElementById('otp-form').classList.add('active');
                
                // Start OTP timer
                startOTPTimer();
                
                // Show success message
                showPrompt('OTP has been sent to your phone number.');
                
                LogRocket.track('OTP Sent Success', {
                    phone: formattedPhone
                });
                
            } catch (error) {
                console.error('Error sending OTP:', error);
                handleSendOTPError(error, phoneInput, formattedPhone);
            }
            
        } catch (error) {
            console.error('Error in manual send OTP:', error);
            showPrompt(error.message || 'An error occurred. Please try again.');
        } finally {
            // Re-enable button
            if (sendButton) {
                sendButton.disabled = false;
                sendButton.textContent = 'Send OTP';
            }
        }
    }
    
    // Update the initializeRecaptcha function to work better
    function initializeRecaptcha() {
        return new Promise((resolve, reject) => {
            try {
                console.log('Starting reCAPTCHA initialization...');
                
                // If reCAPTCHA is already initialized and valid, clear it
                if (recaptchaVerifier) {
                    console.log('Clearing existing reCAPTCHA');
            recaptchaVerifier.clear();
            recaptchaVerifier = null;
        }

        // Clear the container
                const container = document.getElementById('recaptcha-container');
                if (!container) {
                    console.error('reCAPTCHA container not found');
                    throw new Error('reCAPTCHA container not found');
                }
                console.log('Clearing reCAPTCHA container...');
                container.innerHTML = '';

                // Create new reCAPTCHA verifier with visible mode
                console.log('Creating new visible reCAPTCHA verifier...');
                recaptchaVerifier = new firebase.auth.RecaptchaVerifier('recaptcha-container', {
            'size': 'normal',
            'callback': (response) => {
                        console.log('reCAPTCHA verified with response:', response);
                        // Do not automatically send OTP, wait for the button click
                        const sendButton = document.getElementById('manual-send-otp-btn');
                        if (sendButton) {
                            sendButton.disabled = false;
                        }
                        resolve(response);
            },
            'expired-callback': () => {
                console.log('reCAPTCHA expired');
                        showPrompt('CAPTCHA expired. Please verify again.');
                        const sendButton = document.getElementById('manual-send-otp-btn');
                        if (sendButton) {
                            sendButton.disabled = true;
                        }
                        // Reinitialize on expiry
                        initializeRecaptcha().catch(console.error);
            }
        });

        // Render the reCAPTCHA
            console.log('Rendering reCAPTCHA...');
                recaptchaVerifier.render().then(function(widgetId) {
                    recaptchaWidgetId = widgetId;
                    console.log('reCAPTCHA rendered successfully with widget ID:', widgetId);
                    // Disable the send button until CAPTCHA is completed
                    const sendButton = document.getElementById('manual-send-otp-btn');
                    if (sendButton) {
                        sendButton.disabled = true;
                    }
                }).catch(function(error) {
                    console.error('reCAPTCHA render error:', error);
                    showPrompt('Failed to load CAPTCHA. Please refresh the page and try again.');
                    reject(error);
                });
        } catch (error) {
                console.error('reCAPTCHA initialization error:', error);
                reject(error);
            }
        });
    }

    // Add a custom auth checker that runs on page load
    document.addEventListener('DOMContentLoaded', () => {
        // Show auth page by default
        document.getElementById('auth-page').classList.add('visible');
        document.getElementById('episodes-page').classList.remove('visible');
        
        // Initialize reCAPTCHA when the page loads
        initializeRecaptcha().catch(error => {
            console.error('Initial reCAPTCHA initialization failed:', error);
        });
        
        // Check if user is logged in via our custom auth
        const isLoggedIn = localStorage.getItem('auth_isLoggedIn') === 'true';
        const phone = localStorage.getItem('auth_phone');
        
        // Only redirect to episodes page if properly authenticated
        if (isLoggedIn && phone && !isRegistrationInProgress) {
            console.log('User is logged in via custom auth, redirecting to episodes page');
            document.getElementById('auth-page').classList.remove('visible');
            document.getElementById('episodes-page').classList.add('visible');
            checkEpisodeCompletion();
        } else {
            // Clear any potentially invalid auth data
            localStorage.removeItem('show_episodes_page');
            console.log('User is not logged in, showing auth page');
        }
    });

    /* Add this function to toggle password visibility */
    function togglePasswordVisibility(inputId, toggleElement) {
        const passwordInput = document.getElementById(inputId);
        
        if (passwordInput.type === 'password') {
            passwordInput.type = 'text';
            toggleElement.textContent = '🔒';
            toggleElement.classList.add('visible');
        } else {
            passwordInput.type = 'password';
            toggleElement.textContent = '👁️';
            toggleElement.classList.remove('visible');
        }
        
        // Focus on the input field after toggling
        passwordInput.focus();
    }

    // Helper function to format remaining time
    function formatTimeRemaining(timestamp) {
        if (!timestamp) return '';
        
        const now = new Date().getTime();
        const diff = timestamp - now;
        
        if (diff <= 0) return '';
        
        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        
        if (hours > 0) {
            return `Unlocks in ${hours}h ${minutes}m`;
        }
        return `Unlocks in ${minutes}m`;
    }

    // Update the checkEpisodeCompletion function
    async function checkEpisodeCompletion() {
        // Check if user is logged in via our custom auth
        const isLoggedIn = localStorage.getItem('auth_isLoggedIn') === 'true';
        const phone = localStorage.getItem('auth_phone');
        
        if (!isLoggedIn || !phone) {
            console.log('No logged in user found, skipping episode completion check');
            return;
        }

        console.log('Checking episode completion for user with phone:', phone);
        
        // Get all episode cards
        const episodeCards = document.querySelectorAll('.episode-card:not(.announcement)');
        console.log('Found episode cards:', episodeCards.length);
        
        try {
            // Get unlock time from localStorage or Firestore
            let nextEpisodeUnlock = parseInt(localStorage.getItem('next_episode_unlock')) || 0;
            let completedEpisodes = [];
            
            // Try to find user data by phone
            const userQuery = await db.collection('userProgress')
                .where('phone', '==', phone)
                .limit(1)
                .get();
            
            if (userQuery.empty) {
                console.log('No user progress found for phone:', phone);
                // Initialize empty progress for new users
                episodeCards.forEach((card, index) => {
                    // First clear any existing classes
                    card.classList.remove('completed', 'next', 'locked');
                    
                    if (index === 0) {
                        // First episode is next
                        card.classList.add('next');
                        const statusElement = card.querySelector('.episode-status');
                        statusElement.textContent = 'PLAY';
                        statusElement.classList.add('blink-text');
                        // Handle special URL for episode 2 and 4
                        if (index + 1 === 2) {
                            card.onclick = () => window.location.href = `episode2/mono2.html?episode=${index + 1}`;
                        } else if (index + 1 === 4) {
                            card.onclick = () => window.location.href = `episode4/mono4.html?episode=${index + 1}`;
                        } else {
                            card.onclick = () => window.location.href = `monologue/monologue1.html?episode=${index + 1}`;
                        }
                    } else {
                        // All other episodes are locked
                        card.classList.add('locked');
                        card.querySelector('.episode-status').textContent = 'LOCKED';
                        card.onclick = null;
                    }
                });
                
                // Update progress bar and text for new users
                const progressBar = document.querySelector('.progress-bar');
                progressBar.style.width = '0%';
                const progressText = document.querySelector('.progress-container + p');
                progressText.textContent = 'Start your reading journey!';
                return;
            }
            
            // Get user data
            const userData = userQuery.docs[0].data();
            completedEpisodes = userData.completedEpisodes || [];
            
            // Use Firestore's timestamp if available
            if (userData.nextEpisodeUnlock) {
                nextEpisodeUnlock = userData.nextEpisodeUnlock.toDate().getTime();
                // Update localStorage for offline access
                localStorage.setItem('next_episode_unlock', nextEpisodeUnlock.toString());
            } else if (userData.episodeCompletedAt) {
                // Fallback: If nextEpisodeUnlock doesn't exist but episodeCompletedAt does, calculate it
                const completedAt = userData.episodeCompletedAt.toDate().getTime();
                nextEpisodeUnlock = completedAt + (24 * 60 * 60 * 1000);
                localStorage.setItem('next_episode_unlock', nextEpisodeUnlock.toString());
            }
            
            console.log('Retrieved user progress:', {
                name: userData.name,
                completedEpisodes: completedEpisodes,
                nextEpisodeUnlock: new Date(nextEpisodeUnlock).toISOString(),
                currentTime: new Date().toISOString()
            });
            
            const now = new Date().getTime();
            const isNextEpisodeUnlocked = now >= nextEpisodeUnlock;
            let nextEpisodeFound = false;
            
            console.log('Next episode unlock status:', {
                isUnlocked: isNextEpisodeUnlocked,
                timeUntilUnlock: nextEpisodeUnlock - now,
                unlockTime: new Date(nextEpisodeUnlock).toISOString(),
                currentTime: new Date(now).toISOString()
            });
            
            // Update episode cards
            episodeCards.forEach((card, index) => {
                const episodeNumber = index + 1;
                console.log(`Processing episode ${episodeNumber}`);
                
                // Remove all classes first
                card.classList.remove('completed', 'next', 'locked');
                
                // Mark completed episodes
                if (completedEpisodes.includes(episodeNumber)) {
                    console.log(`Episode ${episodeNumber} is completed`);
                    card.classList.add('completed');
                    card.querySelector('.episode-status').textContent = 'COMPLETED';
                    // Special handling for episodes 2 and 4
                    if (episodeNumber === 2) {
                        card.onclick = () => window.location.href = `episode2/mono2.html?episode=${episodeNumber}`;
                    } else if (episodeNumber === 4) {
                        card.onclick = () => window.location.href = `episode4/mono4.html?episode=${episodeNumber}`;
                    } else {
                        card.onclick = () => window.location.href = `monologue/monologue1.html?episode=${episodeNumber}`;
                    }
                }
                // Find next incomplete episode
                else if (!nextEpisodeFound && 
                (episodeNumber === 1 || completedEpisodes.includes(episodeNumber - 1))) {
                    
                    // Check if the next episode is unlocked or if it's the first episode
                    if (episodeNumber === 1 || isNextEpisodeUnlocked || completedEpisodes.includes(episodeNumber - 1)) {
                        console.log(`Episode ${episodeNumber} is next`);
                        card.classList.add('next');
                        const statusElement = card.querySelector('.episode-status');
                        statusElement.textContent = 'PLAY';
                        statusElement.classList.add('blink-text');
                        // Special handling for episodes 2 and 4
                        if (episodeNumber === 2) {
                            card.onclick = () => window.location.href = `episode2/mono2.html?episode=${episodeNumber}`;
                        } else if (episodeNumber === 4) {
                            card.onclick = () => window.location.href = `episode4/mono4.html?episode=${episodeNumber}`;
                        } else {
                            card.onclick = () => window.location.href = `monologue/monologue1.html?episode=${episodeNumber}`;
                        }
                        nextEpisodeFound = true;
                    } else {
                        // Show countdown for locked next episode
                        console.log(`Episode ${episodeNumber} is time-locked`);
                        card.classList.add('locked');
                        const statusElement = card.querySelector('.episode-status');
                        const remaining = formatTimeRemaining(nextEpisodeUnlock);
                        statusElement.textContent = remaining || 'LOCKED';
                        statusElement.style.fontSize = '12px';
                        statusElement.style.whiteSpace = 'nowrap';
                        card.onclick = null;
                        
                        // Update the status text every minute
                        const updateInterval = setInterval(() => {
                            const remaining = formatTimeRemaining(nextEpisodeUnlock);
                            if (remaining) {
                                statusElement.textContent = remaining;
                            } else {
                                clearInterval(updateInterval);
                                // Reload the page to update the UI when the timer expires
                                window.location.reload();
                            }
                        }, 60000);
                        
                        nextEpisodeFound = true; // Still mark as found to prevent showing later episodes
                    }
                }
                // Lock remaining episodes
                else {
                    console.log(`Episode ${episodeNumber} is locked`);
                    card.classList.add('locked');
                    card.querySelector('.episode-status').textContent = 'LOCKED';
                    card.onclick = null;
                }
            });

            // Update progress bar
            const progressBar = document.querySelector('.progress-bar');
            const progressPercentage = (completedEpisodes.length / 5) * 100;
            progressBar.style.width = `${progressPercentage}%`;
            console.log(`Progress: ${progressPercentage}%`);

            // Update progress text
            const progressText = document.querySelector('.progress-container + p');
            if (completedEpisodes.length === 5) {
                progressText.textContent = 'All episodes completed! 🎉';
            } else {
                progressText.textContent = `${completedEpisodes.length} out of 5 episodes completed`;
            }
        } catch (error) {
            console.error('Error checking episode completion:', error);
        }
    }
  </script>
  <!-- Disable search functionality -->
  <script src="disable-search.js"></script>
  <script>
    function getCompletedEpisodes() {
      try {
        return JSON.parse(localStorage.getItem('completedEpisodes') || '[]');
      } catch (e) {
        return [];
      }
    }

    function updateUIBasedOnCompletedEpisodes(completedEpisodes) {
      completedEpisodes.forEach(epNum => {
        const card = document.getElementById('ep' + epNum);
        if (card) card.classList.add('completed');
      });
    }

    window.addEventListener('DOMContentLoaded', function() {
      document.body.classList.add('loading');
      const completedEpisodes = getCompletedEpisodes();
      updateUIBasedOnCompletedEpisodes(completedEpisodes);
      document.getElementById('loadingOverlay').style.opacity = '0';
      setTimeout(() => {
        document.getElementById('loadingOverlay').style.display = 'none';
        document.body.classList.remove('loading');
      }, 300);
    });
  </script>
</body>
</html>